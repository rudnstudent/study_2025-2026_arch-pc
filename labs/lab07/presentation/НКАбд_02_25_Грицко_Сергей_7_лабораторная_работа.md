**РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ** 

**Факультет физико-математических и естественных наук Кафедра прикладной информатики и теории вероятностей** 

**ОТЧЕТ**  

**ПО ЛАБОРАТОРНОЙ РАБОТЕ № 7** 

*дисциплина:  Архитектура компьютера ![](Aspose.Words.9d185f07-4ea4-48b4-b813-cf6bb4b5641e.001.png)*

Студент: Грицко Сергей         Группа:НКАбд-02-25         

**МОСКВА** 2025 г. 

Оглавление 

[Цель работы....................................................................................................................................................................... 3 ](#_page2_x54.00_y56.92)[Теоретическое введение ................................................................................................................................................... 4](#_page3_x54.00_y56.92)

1. [Безусловный переход ............................................................................................................................................. 4](#_page3_x54.00_y214.92)
1. [Условные переходы ................................................................................................................................................ 4](#_page3_x54.00_y429.92)
3. [Команда сравнения CMP ....................................................................................................................................... 5](#_page4_x54.00_y77.92)
3. [Таблица команд условного перехода .................................................................................................................... 5](#_page4_x54.00_y271.92)

[Выполнение лабораторной работы ................................................................................................................................. 6](#_page5_x54.00_y56.92)

2. [Программа с условными переходами ................................................................................................................... 6](#_page5_x54.00_y601.92)
2. [Изучение файла листинга...................................................................................................................................... 7](#_page6_x54.00_y341.92)

[Задания  для  самостоятельной  работы .......................................................................................................................... 8](#_page7_x54.00_y56.92)

[Задание 4.1. Нахождение наименьшего из трех чисел .............................................................................................. 8](#_page7_x54.00_y144.92)

[Задание 4.2. Вычисление значения функции .............................................................................................................. 8 ](#_page7_x54.00_y524.92)[Выводы ............................................................................................................................................................................10 ](#_page9_x54.00_y56.92)[Список литературы .........................................................................................................................................................11](#_page10_x54.00_y56.92)

<a name="_page2_x54.00_y56.92"></a>**Цель работы** 

Целью данной лабораторной работы является изучение команд условного и безусловного переходов в языке ассемблера NASM. Необходимо приобрести практические навыки написания программ с использованием механизмов ветвления и циклов, что позволяет реализовывать сложные нелинейные алгоритмы. Также важной частью работы является знакомство с назначением и структурой файла листинга (.lst), который необходим для отладки и анализа низкоуровневого кода. 

<a name="_page3_x54.00_y56.92"></a>**Теоретическое введение**

Процессор по умолчанию выполняет инструкции последовательно, одну за другой, в том порядке, в котором они записаны в памяти. Однако для реализации алгоритмов, содержащих условия (конструкции if-else) или циклы (конструкции for, while), необходимо нарушать этот порядок. Для этого в ассемблере используются команды передачи управления. Можно выделить два основных типа переходов: 

1. ***Безусловный<a name="_page3_x54.00_y214.92"></a> переход*** 

Безусловный переход выполняется инструкцией jmp (от англ. *jump* — прыжок). Она 

передает управление по указанному адресу без проверки каких-либо условий. 

Синтаксис: 

jmp <адрес\_перехода> 

Адрес перехода может быть задан меткой, адресом в области памяти или именем регистра. В последнем случае переход происходит по адресу, хранящемуся в регистре. Это аналог оператора goto в языках высокого уровня. 

2. ***Условные<a name="_page3_x54.00_y429.92"></a> переходы*** 

Условные переходы осуществляют передачу управления только в том случае, если 

выполняется определенное условие. Если условие не выполняется, процессор просто переходит к следующей инструкции. 

Условия базируются на состоянии **регистра флагов (EFLAGS)**. Флаги — это биты, которые меняют свое значение (0 или 1) в зависимости от результата предыдущей арифметической или логической операции. 

Основные флаги, используемые для переходов: 

1. **ZF (Zero Flag)** — Флаг нуля. Устанавливается в 1, если результат операции равен нулю. 
1. **SF (Sign Flag)** — Флаг знака. Устанавливается в 1, если результат операции отрицательный (старший бит равен 1). 
1. **CF (Carry Flag)** — Флаг переноса. Устанавливается в 1, если при арифметической операции произошло переполнение беззнакового числа (перенос из старшего разряда). 
4. **OF (Overflow Flag)** — Флаг переполнения. Используется для знаковой арифметики. 
3. ***Команда<a name="_page4_x54.00_y77.92"></a> сравнения CMP*** 

Для проверки условий чаще всего используется команда cmp (от англ. *compare*).  

Синтаксис: 

cmp <операнд1>, <операнд2> 

Механизм работы: команда выполняет вычитание операнд1 - операнд2, но, в отличие от команды sub, **не сохраняет результат** вычитания в операнде. Единственным результатом работы команды является изменение флагов в регистре EFLAGS. 

4. ***Таблица<a name="_page4_x54.00_y271.92"></a> команд условного перехода*** 

Команды перехода делятся на команды для знаковых и беззнаковых чисел. 

**Мнемоника  Описание условия  Анализируемые флаги JE** (Jump Equal)  Переход, если равно  ZF = 1 

**JNE** (Jump Not Equal)  Переход, если не равно  ZF = 0 

**JG** (Jump Greater)  Переход, если больше (со знаком) ZF = 0 и SF = OF 

**JL** (Jump Less)  Переход, если меньше (со знаком) SF ≠ OF 

**JGE** (Jump Greater or Equal) Переход, если больше или равно  SF = OF 

**JLE** (Jump Less or Equal)  Переход, если меньше или равно  ZF = 1 или SF ≠ OF 

**JA** (Jump Above)  Переход, если выше (без знака)  CF = 0 и ZF = 0 

**JB** (Jump Below)  Переход, если ниже (без знака)  CF = 1 

*Таблица 1. Команды условного перехода* 

<a name="_page5_x54.00_y56.92"></a>**Выполнение лабораторной работы** 

Для начала работы я создал каталог lab07 в своей рабочей директории и перешел в него. Затем я создал файл lab7-1.asm с помощью текстового редактора. 

Задача состояла в том, чтобы написать программу, использующую инструкцию jmp для изменения порядка вывода сообщений на экран. 

**Текст программы lab7-1.asm:** *(Смотри файл lab7-1.asm, приложенный к отчету)* 

В данной программе я использовал три метки: \_label1, \_label2, \_label3 и метку завершения \_end. Логика работы программы следующая: 

1. Сразу после старта (\_start) выполняется безусловный переход jmp \_label3. 
1. Программа переходит к метке \_label3, где выводится "Сообщение № 3", после чего выполняется jmp \_label2. 
1. Управление  передается  на  метку  \_label2,  выводится  "Сообщение  №  2",  затем  идет переход jmp \_label1. 
1. На метке \_label1 выводится "Сообщение № 1" и выполняется финальный переход jmp \_end. 
1. На метке \_end программа корректно завершает работу. 

**Компиляция и запуск:** Я использовал следующие команды для сборки: 

![](Aspose.Words.9d185f07-4ea4-48b4-b813-cf6bb4b5641e.002.png)

*Рисунок 1. Команды для сборки* 

**Результат работы программы:** 

![](Aspose.Words.9d185f07-4ea4-48b4-b813-cf6bb4b5641e.003.png)

*Рисунок 2. Вывод сообщений в обратном порядке* 

Как видно на скриншоте, несмотря на то, что в коде сообщения записаны \
последовательно, инструкция jmp позволила изменить порядок их вывода на обратный. 

2. ***Программа<a name="_page5_x54.00_y601.92"></a> с условными переходами*** 

Во втором задании требовалось написать программу, которая определяет наибольшее из трех чисел: переменные A и C заданы в коде, а B вводится с клавиатуры. 

Я создал файл lab7-2.asm. Для реализации ввода и сравнения чисел я использовал функции из подключаемого файла in\_out.asm. Особое внимание я уделил тому, что ввод с клавиатуры дает символьную строку, которую необходимо преобразовать в целое число функцией atoi перед выполнением арифметического сравнения. 

**Текст программы lab7-2.asm:** *(Смотри файл lab7-2.asm, приложенный к отчету)* 

**Алгоритм работы программы:** 

1. Программа выводит приглашение "Введите B". 
1. Считывает строку с консоли. 
1. Преобразует введенную строку в число (функция atoi). 
1. Сравнивает жестко заданное число A с числом C. Если A > C, то программа запоминает A как текущий максимум, иначе — C. 
1. Затем текущий максимум сравнивается с введенным числом B. Если B больше, то оно становится новым максимумом. 
1. Результат выводится на экран. 

![](Aspose.Words.9d185f07-4ea4-48b4-b813-cf6bb4b5641e.004.png)

*Рисунок 3. Запуск программы с вводом числа* 

Программа корректно определяет максимальное число. 

3. ***Изучение<a name="_page6_x54.00_y341.92"></a> файла листинга*** 

Файл листинга — это текстовый файл, который генерируется ассемблером и показывает взаимосвязь между исходным кодом и машинными инструкциями. Я создал файл листинга командой: 

![](Aspose.Words.9d185f07-4ea4-48b4-b813-cf6bb4b5641e.005.png)

*Рисунок 4. Выполнение команды* 

Затем я открыл полученный файл lab7-2.lst в текстовом редакторе. Вот фрагмент содержимого файла: 

![](Aspose.Words.9d185f07-4ea4-48b4-b813-cf6bb4b5641e.006.png)

*Рисунок 5. Просмотр файла листинга* 

Разберем одну из строк листинга подробно: 

1. **35, 36** — это номера строк в исходном коде .asm. 
1. **00000045, 0000004B** — это смещения (адреса) команд от начала сегмента кода в шестнадцатеричном формате. 
1. **3B0D[16000000]** — машинный код команды cmp ecx, [C]. 
1. **7F0C** — машинный код команды jg check\_B. Здесь 7F — это код операции (опкод) перехода, а 0C — это операнд, указывающий, на сколько байт нужно прыгнуть вперед. 

**Эксперимент с ошибкой:** Я попробовал удалить один из операндов в инструкции cmp и снова запустить сборку с ключом -l. Ассемблер выдал ошибку invalid combination of opcode and operands в терминал. При этом **файл листинга не был создан**. Это доказывает, что листинг формируется только при успешной трансляции кода. 

<a name="_page7_x54.00_y56.92"></a>**Задания для самостоятельной работы**

**Вариант задания: 14** 

<a name="_page7_x54.00_y144.92"></a>***Задание 4.1. Нахождение наименьшего из трех чисел*** 

**Условие:** Даны три числа: a = 81, b = 22, c = 72. Необходимо написать программу на ассемблере, которая находит наименьшее из них. 

Я создал файл lab7-3.asm. **Алгоритм решения:** 

1. Принимаем за условный минимум (min) первое число a (81). Для этого помещаем его в регистр EAX. 
1. Сравниваем текущий min (в EAX) со вторым числом b (22). 
1. Используем команду cmp eax, [b] и переход jl (jump less). 
1. Если значение в EAX меньше b, пропускаем шаг обновления. Но так как 81 > 22, условие "меньше" не выполняется. Мы обновляем min: mov eax, [b]. Теперь в EAX число 22. 
1. Сравниваем текущий min (22) с третьим числом c (72). 
1. Так как 22 < 72, обновление не требуется. 
1. Выводим значение регистра EAX. 

**Листинг программы lab7-3.asm:** *(Полный код представлен в приложенном файле lab7- 3.asm)* 

**Результат работы:** 

![](Aspose.Words.9d185f07-4ea4-48b4-b813-cf6bb4b5641e.007.png)

*Рисунок 6. Результат работы программы поиска минимума* 

Программа выдала число 22, что является верным ответом, так как 22 < 72 и 22 < 81. <a name="_page7_x54.00_y524.92"></a>***Задание 4.2. Вычисление значения функции*** 

**Условие:** Напишите программу, которая для введенных с клавиатуры значений x и a вычисляет значение заданной функции f(x) и выводит результат.  

**Алгоритм (блок-схема логики):** 

1. **Ввод данных:** Считываем строки x и a с клавиатуры, преобразуем их в целые числа (функция atoi) и сохраняем в переменные. 
1. **Сравнение:** Выполняем команду cmp [x], [a]. 
1. **Ветвление:** 
1. Если x и a (используем инструкцию jge case\_greater\_equal), переходим к метке расчета второй формулы. 
1. Если условие ложно (значит x < a), продолжаем выполнение следующей строки кода (первая формула). 
4. **Вычисление ветви 1 (x < a):** 
   1. Загружаем a в регистр EAX. 
   1. Умножаем на 3 (mov ebx, 3, mul ebx). 
   1. Прибавляем 1 (add eax, 1). 
   1. Безусловно переходим к выводу (jmp print\_res), чтобы пропустить код второй ветки. 
5. **Вычисление ветви 2 (x и a):** 
1. Метка case\_greater\_equal. 
1. Загружаем x в регистр EAX. 
1. Умножаем на 3. 
1. Прибавляем 1. 
6. **Вывод:** Печатаем значение из EAX. 

**Листинг программы lab7-4.asm:** *(Полный код представлен в приложенном файле lab7- 4.asm)* 

**Тестирование программы:** Для проверки правильности алгоритма я провел два теста с разными входными данными. 

*Тест 1:* Ввод: x = 2, a = 3. Проверка условия: 2 < 3 (истина). Ожидаемый результат: f(x) = 3 \*3 + 1 = 10. 

*Тест 2:* Ввод: x = 4, a = 2. Проверка условия: 4 и 2 (истина). Ожидаемый результат: f(x) = 3 \* 4 + 1 = 13. 

**Скриншот с результатами тестов:** 

![](Aspose.Words.9d185f07-4ea4-48b4-b813-cf6bb4b5641e.008.png)

*Рисунок 7. Проверка вычисления функции* 

Программа работает корректно и выдает ожидаемые математические результаты. 

<a name="_page9_x54.00_y56.92"></a>**Выводы**

В ходе выполнения лабораторной работы №7 я изучил механизмы управления потоком выполнения программ в архитектуре i386 с использованием ассемблера NASM. 

**Мною были выполнены следующие задачи:** 

1. Изучены теоретические основы ветвлений: роль регистра флагов (EFLAGS) и принцип работы команд переходов. 
1. На практике освоена работа с инструкцией безусловного перехода jmp. Я убедился, что с её помощью можно произвольно менять порядок выполнения команд, создавая "спагетти-код" или, наоборот, структурированные циклы. 
1. Реализованы программы с условными переходами. Я научился комбинировать команду сравнения cmp с командами jl, jg, jge для реализации логики if-else. Это позволило решить задачи поиска максимума и минимума чисел, а также вычисления кусочно-заданной функции. 
1. Проведен анализ файла листинга (.lst). Я выяснил, что листинг является мощным инструментом отладки, позволяющим увидеть машинный код и проверить корректность трансляции меток и адресов переходов. Опытным путем подтверждено, что листинг генерируется только при отсутствии синтаксических ошибок в коде. 

Таким образом, цель работы достигнута: я приобрел навыки программирования ветвлений на ассемблере, что является базой для реализации любых сложных алгоритмов на низком уровне. 

<a name="_page10_x54.00_y56.92"></a>**Список литературы**

1. GDB: The GNU Project Debugger. — URL:[ https://www.gnu.org/software/gdb/.](https://www.gnu.org/software/gdb/) 
1. NASM Assembly Language Tutorials. — 2021. — URL:[ https://asmtutor.com/.](https://asmtutor.com/) 
1. Колдаев В. Д., Лупин С. А. Архитектура ЭВМ. — М. : Форум, 2018. 
1. Куляс О. Л., Никитин К. А. Курс программирования на ASSEMBLER. — М. : Солон- Пресс, 2017. 
1. Столяров А. Программирование на языке ассемблера NASM для ОС Unix. — 2-е изд. 
   1. М. : МАКС Пресс, 2011. 
1. Таненбаум Э. Архитектура компьютера. — 6-е изд. — СПб. : Питер, 2013. — 874 с. 
12 
