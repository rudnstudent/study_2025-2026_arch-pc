**РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ** 

**Факультет физико-математических и естественных наук Кафедра прикладной информатики и теории вероятностей** 

**ОТЧЕТ**  

**ПО ЛАБОРАТОРНОЙ РАБОТЕ № 6** 

*дисциплина:  Архитектура компьютера ![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.001.png)*

Студент: Грицко Сергей         Группа: НКАбд-02-25         

**МОСКВА** 2025 г. 

Оглавление 

[Цель работы....................................................................................................................................................................... 3 ](#_page2_x54.00_y56.92)[Описание результатов выполнения лабораторной работы ............................................................................................ 4 ](#_page3_x54.00_y56.92)[Описание результатов выполнения заданий для самостоятельной работы ................................................................. 8](#_page7_x54.00_y56.92)

<a name="_page2_x54.00_y56.92"></a>**Цель работы**

Освоение арифметических инструкций языка ассемблера NASM. 

<a name="_page3_x54.00_y56.92"></a>**Описание результатов выполнения лабораторной работы**

Сначала я создал каталог lab06 и скопировал в этот каталог файл in\_out.asm с прошлой лабы. 

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.002.png)

Рисунок 1. Создание каталога 

Далее создал файл lab6-1.asm (Листинг 6.1 из методички) и скомпилировал его. 

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.003.png)

Рисунок 2. Выполнение первой версии lab6-1.asm, где виден вывод 'j' 

Когда я запустил первую версию lab6-1.asm (которая складывала eax, '6' и ebx, '4'), программа вывела символ j. Это было ожидаемо, потому что на самом деле сложились не числа, а их ASCII-коды (54 + 52 = 106), а 106 — это как раз код символа j. 

Потом я изменил lab6-1.asm, заменив '6' на 6 и '4' на 4. Снова скомпилировал и запустил. 

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.004.png)

Рисунок 3. Выполнение второй версии lab6-1.asm, где виден "пустой" вывод 

В этот раз программа вывела "пустую строку" (просто перевела курсор). Я посмотрел в таблицу ASCII — код 10, который получился (6 + 4), это символ "Line Feed" или \n (перевод строки). Функция sprintLF выводит строку по адресу, а по адресу 10 в памяти ничего осмысленного нет, но так как в eax было 10, sprintLF (которая ожидает адрес) отработала некорректно, но call quit все равно завершил программу. В общем, sprintLF не предназначена для вывода чисел. 

Далее я создал файл lab6-2.asm (Листинг 6.2), который использует iprintLF (функцию для вывода *чисел*). 

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.005.png)

Рисунок 4. lab6-2.asm с символами, вывод '106' 

Сначала со значениями '6' и '4' программа вывела 106. Это логично, iprintLF взяла результат сложения ASCII-кодов (54 + 52) и вывела его уже как число.

Я изменил lab6-2.asm на использование чисел 6 и 4. 

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.006.png)

Рисунок 5. Выполнение lab6-2.asm с числами, вывод '10' 

Наконец-то! Программа корректно сложила 6 и 4 и вывела число 10. Теперь понятно, что iprintLF — для чисел, а sprintLF — для строк (символов). 

В конце я заменил iprintLF на iprint. 

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.007.png)

Рисунок 6. Выполнение lab6-2.asm с iprint, где вывод "слипся" со строкой терминала 

Разница оказалась в том, что iprintLF (LF = Line Feed) добавляет перевод строки в конце, а iprint — нет. Моя командная строка просто "прилипла" к числу 10. 

Я создал файл lab6-3.asm (Листинг 6.3). Он считал (5\*2+3)/3.

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.008.png)

Рисунок 7. Выполнение lab6-3.asm с первым выражением 

Программа успешно вывела Результат: 4 и Остаток от деления: 1. Это верно, т.к. (5\*2+3)/3 = 13/3 = 4 и 1 в остатке. Код был понятный, особенно xor edx, edx перед делением для очистки edx. 

Я изменил lab6-3.asm для вычисления f(x) = (4\*6+2)/5. 

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.009.png)

Рисунок 8. Выполнение lab6-3.asm со вторым выражением 

Я просто заменил константы в коде: mov eax, 4, mov ebx, 6, add eax, 2, mov ebx, 5 и программа вывела Результат: 5 и Остаток от деления: 1. Это тоже верно: (4\*6+2)/5 = 26/5 = 5 и 1 в остатке. 

Теперь надо написать программу, которая запрашивает номер студенческого билета, считывает его, и вычисляет номер варианта по формуле (Номер mod 20) + 1. 

Я создал файл variant.asm и скомпилировал и запустил. 

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.010.png)

Рисунок 9. Выполнение variant.asm, ввод номера 1032251953 и вывод варианта 14 

Я ввел свой (условный) номер 123453. Программа правильно использовала sread для чтения строки, atoi для превращения ее в число, а затем div ebx (где ebx = 20) для получения остатка. Остаток (13) сохранился в edx, потом inc edx (стало 14), и iprintLF вывела мой вариант. 

<a name="_page7_x54.00_y56.92"></a>**Описание результатов выполнения заданий для самостоятельной работы**

**Описание задания:** Нужно было написать программу для вычисления выражения  =  ( ) по номеру варианта. Мой вариант - 14. 

- **Функция:** f(x) = (x/2 + 8) \* 3 
- **Контрольные значения:** x1 = 1, x2 = 4 

Программа должна выводить формулу, запрашивать x, считать и выводить результат. 

**Проверка x1 = 1:** 

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.011.png)

Рисунок 10. Выполнение lab6-task.asm с вводом x=1 и выводом 24 

Я запустил программу и ввел 1. Программа вывела Resultat: 24. (1 / 2 + 8) \* 3 = (0 + 8) 

\* 3 = 8 \* 3 = 24. (Примечание: 1/2 = 0 в целочисленном делении). **Вывод:** Совпало. Программа работает верно.

**Проверка x2 = 4:** 

![](Aspose.Words.7d6b78fb-2ed4-4bb3-b0df-7133367e2f05.012.png)

Рисунок 11. Выполнение lab6-task.asm с вводом x=4 и выводом 30 

Я запустил программу еще раз и ввел 4. Программа вывела Resultat: 30. (4 / 2 + 8) \* 3 = (2 + 8) \* 3 = 10 \* 3 = 30. **Вывод:** Снова совпало. 

**Вывод** 

В ходе выполнения этой лабораторной работы я достиг поставленной цели — **освоил арифметические инструкции языка ассемблера NASM**. 

Я на практике увидел разницу между символьными данными (ASCII-кодами) и настоящими числами, и понял, почему для работы с ними нужны разные функции (sprint vs iprint, atoi). 

Я научился использовать базовые арифметические команды: 

1. add (сложение) 
1. inc (инкремент) 
1. mul (умножение без знака) 
1. div (деление без знака) 

Особенно важным было понять, как работает деление: что eax — это делимое, ebx — делитель, результат (частное) кладется в eax, а остаток — в edx, и что edx обязательно нужно обнулять (xor edx, edx) перед делением. 

Самостоятельное задание помогло закрепить навыки: я смог с нуля написать программу, которая считывает данные, проводит последовательность вычислений (div, add, mul) и выводит корректный результат. 

**Список литературы**

1. GDB: The GNU Project Debugger. — URL: https://www.gnu.org/software/gdb/. 
1. GNU Bash Manual. — 2016. — URL: https://www.gnu.org/software/bash/manual/. 
1. Midnight Commander Development Center. — 2021. — URL: https://midnight- commander.org/. 
1. NASM Assembly Language Tutorials. — 2021. — URL: https://asmtutor.com/. 
1. Newham C. Learning the bash Shell: Unix Shell Programming. — O’Reilly Media, 2005. — 354 с. — (In a Nutshell). — ISBN 0596009658. — URL: http://www.amazon.com/Learning-bash-Shell-Programming-Nutshell/dp/0596009658. 
1. Robbins A. Bash Pocket Reference. — O’Reilly Media, 2016. — 156 с. — ISBN 978- 1491941591. 
1. The NASM documentation. — 2021. — URL: https://www.nasm.us/docs.php. 
1. Zarrelli G. Mastering Bash. — Packt Publishing, 2017. — 502 с. — ISBN 9781784396879. 
1. Колдаев В. Д., Лупин С. А. Архитектура ЭВМ. — М. : Форум, 2018. 
1. Куляс О. Л., Никитин К. А. Курс программирования на ASSEMBLER. — М. : Солон- Пресс, 2017. 
1. Новожилов О. П. Архитектура ЭВМ и систем. — М. : Юрайт, 2016. 
1. Расширенный ассемблер: NASM. — 2021. — URL: https://www.opennet.ru/docs/RUS/nasm/. 
1. Робачевский А., Немнюгин С., Стесик О. Операционная система UNIX. — 2-е изд. — БХВ-Петербург, 2010. — 656 с. — ISBN 978-5-94157-538-1. 
1. Столяров А. Программирование на языке ассемблера NASM для ОС Unix. — 2-е изд. 
   1. М. : МАКС Пресс, 2011. — URL: http://www.stolyarov.info/books/asm\_unix. 
1. Таненбаум Э. Архитектура компьютера. — 6-е изд. — СПб. : Питер, 2013. — 874 с. — (Классика Computer Science). 
1. Таненбаум Э., Бос Х. Современные операционные системы. — 5-е изд. — СПб. : Питер, 2018. — 1120 с. — (Классика Computer Science). 
10 
