**РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ** 

**Факультет физико-математических и естественных наук Кафедра прикладной информатики и теории вероятностей** 

**ОТЧЕТ**  

**ПО ЛАБОРАТОРНОЙ РАБОТЕ № 8** 

*дисциплина:  Архитектура компьютера ![](Aspose.Words.0388fb0d-4f15-4a03-aeb8-10d00625e3da.001.png)*

Студент: Грицко Сергей         Группа: НКАбд-02-25         

**МОСКВА** 2025 г. 

Оглавление 

[Цель работы....................................................................................................................................................................... 3 ](#_page2_x54.00_y56.92)[Теоретическое введение ................................................................................................................................................... 4](#_page3_x54.00_y56.92)

1. [Организация Стека.................................................................................................................................................. 4](#_page3_x54.00_y110.92)
1. [Программирование циклов .................................................................................................................................... 5](#_page4_x54.00_y70.92)
1. [Обработка аргументов командной строки ............................................................................................................ 5](#_page4_x54.00_y327.92)

[Порядок выполнения лабораторной работы................................................................................................................... 6](#_page5_x54.00_y56.92)

1. [Реализация циклов в NASM................................................................................................................................... 6](#_page5_x54.00_y112.92)
1. [Обработка аргументов командной строки ........................................................................................................... 7](#_page6_x54.00_y56.92)
1. [Арифметические операции с аргументами (Вычисление произведения) ........................................................ 7](#_page6_x54.00_y423.92)

[Порядок выполнения самостоятельной работы............................................................................................................. 8 ](#_page7_x54.00_y166.92)[Выводы .............................................................................................................................................................................. 9 ](#_page8_x54.00_y56.92)[Список литературы .........................................................................................................................................................10](#_page9_x54.00_y56.92)

<a name="_page2_x54.00_y56.92"></a>**Цель работы** 

Приобретение навыков написания программ с использованием циклов и обработкой аргументов командной строки. 

<a name="_page3_x54.00_y56.92"></a>**Теоретическое введение**

1. *Организация<a name="_page3_x54.00_y110.92"></a> Стека*** 

Стек — это фундаментальная структура данных, реализованная на аппаратном уровне 

в архитектуре процессора, работающая по принципу **LIFO** (Last In — First Out, «последним пришел — первым ушел»). Он необходим для сохранения адресов возврата при вызове процедур, выделения памяти под локальные переменные и временного хранения значений регистров. 

Вершина стека — это адрес последнего добавленного элемента, который хранится в регистре **ESP** (Stack Pointer, указатель стека). Дно стека находится на противоположном 

конце. Основными операциями со стеком являются:

![](Aspose.Words.0388fb0d-4f15-4a03-aeb8-10d00625e3da.002.png)

*Рисунок 1. Организация стека в процессоре*

- **PUSH**: Добавление элемента в вершину стека. При выполнении этой команды указатель стека ESP уменьшается. 
- **POP**: Извлечение элемента из вершины стека. При этом указатель стека ESP увеличивается. 

Использование стека, как будет показано ниже, критически важно для сохранения \
контекста регистров при выполнении сложных операций, включая циклы и вызовы функций. 

2. *Программирование<a name="_page4_x54.00_y70.92"></a> циклов*** 

Для организации циклов в ассемблере NASM используется команда **loop**. Эта команда 

выполняет две основные функции: 

1. Уменьшает значение счетчика цикла, хранящегося в регистре **ECX** (Extended Count Register), на 1. 
1. Проверяет, равно ли новое значение ECX нулю. Если не равно, происходит переход на метку, указанную в качестве операнда loop. Если равно нулю, выполнение программы продолжается со следующей после loop инструкции. 

Поскольку регистр ECX автоматически используется командой loop, его нельзя изменять внутри тела цикла для других целей. Если возникает такая необходимость, требуется временно сохранять (PUSH) и восстанавливать (POP) его значение, чтобы не нарушить логику итераций. 

3. *Обработка<a name="_page4_x54.00_y327.92"></a> аргументов командной строки*** 

При запуске программы из командной строки операционная система использует стек 

для передачи данных программе. В стек помещаются следующие элементы (снизу вверх): 

1. **argc** (Argument Count): Количество аргументов, переданных программе (включая имя самой программы). 
1. **argv[0]**: Адрес строки, содержащей имя программы. 
1. **argv[1], argv[2], ... argv[n-1]**: Адреса строк, содержащих сами аргументы. 

Для доступа к этим данным программа в ассемблере использует инструкцию **pop** для извлечения значений из стека. Сначала извлекается argc (количество), затем argv[0] (имя программы), а затем в цикле — адреса остальных аргументов. Аргументы командной строки всегда передаются как строки, поэтому для выполнения над ними арифметических операций необходимо использовать специальные библиотечные функции (например, atoi из in\_out.asm) для преобразования строки в число. 

<a name="_page5_x54.00_y56.92"></a>Порядок** выполнения** лабораторной** работы** 

1. *Реализация<a name="_page5_x54.00_y112.92"></a> циклов в **NASM*** 

Мной была написана программа lab8-1.asm для демонстрации работы циклов и 

важности сохранения контекста регистра ecx. 

При написании программы я столкнулся с тем, что изменение регистра ecx внутри тела цикла (например, при его декременте инструкцией sub ecx, 1) приводило к некорректной работе команды loop, так как она тоже использует ecx как счетчик. 

Для обеспечения надежности работы цикла, я использовал стек: 

1. Перед изменением: push ecx (сохраняю текущий счетчик). 
1. После выполнения операций: pop ecx (восстанавливаю счетчик). Это позволило выполнять внутренние операции с ecx без сбоя логики итераций. 

**Текст программы lab8-1.asm:** *(Смотри файл lab8-1.asm, приложенный к отчету)* **Результат работы программы:** 

![](Aspose.Words.0388fb0d-4f15-4a03-aeb8-10d00625e3da.003.png)

*Рисунок 2. Скриншот выполнения программы lab8-1* 

*Вывод:* Использование стека позволяет корректно использовать регистр ecx для вычислений внутри цикла, не нарушая работу основного счетчика итераций, что подтверждает успешное выполнение программы. 

2. ***Обработка<a name="_page6_x54.00_y56.92"></a> аргументов командной строки*** 

Я написал программу lab8-2.asm, которая демонстрирует, как получить и вывести на экран 

все аргументы, переданные ей при запуске. Первым делом программа извлекает из стека количество аргументов (argc) и имя самой программы (argv[0]), затем в цикле последовательно извлекает и печатает остальные аргументы. 

**Текст программы lab8-2.asm:** *(Смотри файл lab8-2.asm, приложенный к отчету)* **Результат работы программы:** 

![](Aspose.Words.0388fb0d-4f15-4a03-aeb8-10d00625e3da.004.png)

*Рисунок 2. Скриншот выполнения программы lab8-2* 

*Вывод:* Программа корректно обработала и вывела на консоль все переданные ей аргументы, демонстрируя базовый механизм работы с argc и argv через стек. 

3. ***Арифметические<a name="_page6_x54.00_y423.92"></a> операции с аргументами (Вычисление произведения)*** 

В данном задании требовалось изменить программу для вычисления суммы 

аргументов на программу, вычисляющую их **произведение**. 

Для этого я выполнил следующие ключевые модификации: 

1. Инициализировал регистр результата (esi) значением **1** (нейтральный элемент для умножения). 
1. Заменил команду add на команду **imul** (умножение целых чисел). 

**Текст программы lab8-3.asm:** *(Смотри файл lab8-3.asm, приложенный к отчету)* **Результат работы программы:** 

![](Aspose.Words.0388fb0d-4f15-4a03-aeb8-10d00625e3da.005.png)

*Рисунок 3. Скриншот выполнения программы lab8-3* 

*Вывод:* Путем изменения инициализации и основной арифметической инструкции программа была успешно модифицирована для вычисления произведения аргументов, что подтверждено результатом. 

<a name="_page7_x54.00_y166.92"></a>**Порядок выполнения самостоятельной работы** 

Вариант №14 

**Задание:** Написать программу, которая находит сумму значений функции f(x) для переданных аргументов x\_1, x\_2, \dots, x\_n. **Вариант 14:** Функция f(x) = x + 12. 

**Алгоритм решения:** 

1. Инициализировать регистр суммы (esi) нулем. 
1. Организовать цикл по всем аргументам командной строки. 
1. В цикле каждый аргумент x преобразовать из строки в число. 
1. Вычислить f(x) = x + 12 (простая операция сложения). 
1. Добавить полученное значение f(x) к регистру суммы esi. 
1. Вывести финальную сумму. 

**Текст программы lab8-4.asm:** *(Смотри файл lab8-4.asm, приложенный к отчету)* **Результат работы программы:** 

![](Aspose.Words.0388fb0d-4f15-4a03-aeb8-10d00625e3da.006.png)

*Рисунок 4. Скриншот выполнения программы lab8-4* 

**Результат выполнения:** Для проверки использовались аргументы x=1 и x=2. f(1) = 1 + 12 = 13 f(2) = 2 + 12 = 14 Общая сумма: 13 + 14 = 27. Команда для проверки: ./lab8-4 1 2 

*Вывод:* Программа корректно обрабатывает аргументы командной строки, преобразует их в формат и вычисляет сумму значений функции f(x) = x + 12 для всех переданных аргументов. 

<a name="_page8_x54.00_y56.92"></a>**Выводы** 

В ходе выполнения лабораторной работы я успешно реализовал и отладил четыре программы на языке ассемблера NASM. Были освоены следующие ключевые навыки и концепции: 

1. **Программирование циклов** с использованием команды loop и корректное управление регистром-счетчиком ecx посредством стека (push/pop). 
1. **Обработка аргументов командной строки** через стек, включая извлечение количества аргументов (argc) и самих аргументов (argv). 
1. **Выполнение арифметических операций** над числовыми аргументами командной строки после их преобразования из строкового формата. Все поставленные задачи выполнены, цель работы достигнута. 

<a name="_page9_x54.00_y56.92"></a>**Список литературы** 

1. GDB: The GNU Project Debugger. — UR[L: https://www.gnu.org/software/gdb/. ](https://www.gnu.org/software/gdb/)
1. NASM Assembly Language Tutorials. — 2021. — URL:[ https://asmtutor.com/. ](https://asmtutor.com/)
1. Колдаев В. Д., Лупин С. А. Архитектура ЭВМ. — М. : Форум, 2018. 
1. Куляс О. Л., Никитин К. А. Курс программирования на ASSEMBLER. — М. : Солон- Пресс, 2017. 
1. Столяров А. Программирование на языке ассемблера NASM для ОС Unix. — 2-е изд. М. : МАКС Пресс, 2011. 
1. Таненбаум Э. Архитектура компьютера. — 6-е изд. — СПб. : Питер, 2013. — 874 с. 12 
11 
