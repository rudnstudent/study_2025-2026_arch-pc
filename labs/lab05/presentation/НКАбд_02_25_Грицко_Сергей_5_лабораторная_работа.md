> **РОССИЙСКИЙ** **УНИВЕРСИТЕТ** **ДРУЖБЫ** **НАРОДОВ**
>
> **Факультет** **физико-математических** **и** **естественных**
> **наук**
>
> **Кафедра** **прикладной** **информатики** **и** **теории**
> **вероятностей**
>
> **ОТЧЕТ**
>
> **ПО** **ЛАБОРАТОРНОЙ** **РАБОТЕ** **№** **5**
>
> *<u>дисциплина: Архитектура компьютера</u>*
>
> <u>Студент: Грицко Сергей</u>
>
> Группа: НКАбд-02-25
>
> **МОСКВА** 2025 г.

Оглавление

**Цель**
**работы**...................................................................................................................................................................................3

**Теоретическое**
**введение**...............................................................................................................................................................4
***2.1.*** ***Midnight*** ***Commander***
***(mc)***..................................................................................................................................................4
***2.2.*** ***Структура*** ***программы*** ***на***
***NASM***.....................................................................................................................................4
***2.3.*** ***Основные*** ***инструкции*** ***и*** ***системные***
***вызовы***
.................................................................................................................4
**Описание** **результатов** **выполнения** **лабораторной**
**работы**..................................................................................................5
**3.1.** **Задание** **1.** **Работа** **в** **Midnight** **Commander**
**и** **создание** **первой**
**программы**..............................................................5
**3.2.** **Задание** **2.** **Подключение** **внешнего** **файла**
**in_out.asm**.................................................................................................8
**Описание** **результатов** **выполнения** **заданий** **для**
**самостоятельной**
**работы**...................................................................10
**4.1.** **Задание** **1.** **Вывод** **введенной** **строки** **(без**
**in_out.asm)**
................................................................................................10
**4.2.** **Задание** **2.** **Вывод** **введенной** **строки** **(с**
**in_out.asm)**....................................................................................................11
**Вывод**............................................................................................................................................................................................13
**Список**
**литературы**....................................................................................................................................................................14

> 2

**Цель** **работы**

Приобретение практических навыков работы в Midnight Commander. Освоение
инструкций языка ассемблера mov и int.

> 3

<img src="./pvse0lbk.png"
style="width:5.20833in;height:2.60417in" />

> **Теоретическое** **введение**
>
> ***2.1.*** ***Midnight*** ***Commander*** ***(mc)***
>
> Midnight Commander (mc) — это файловый менеджер для консоли, который
> упрощает работу с файлами. Он запускается командой mc и представляет
> собой две панели, между которыми можно копировать и перемещать файлы.
>
> Основные клавиши, которые я использовал в работе:

||
||
||
||
||
||
||
||
||

> *Таблица* *1.* *Основные* *клавиши*

***2.2.*** ***Структура*** ***программы*** ***на*** ***NASM***

Программа на ассемблере NASM, которую мы писали, состоит из нескольких
секций.

> *Рисунок* *1.* *Синтаксис* *описания* *сегмента*

Выполнение программы начинается с метки \_start, которую нужно объявить
глобальной с помощью GLOBAL \_start.

***2.3.*** ***Основные*** ***инструкции*** ***и*** ***системные***
***вызовы***

В работе я освоил две главные инструкции:

> 1\. **mov** **(move):** Инструкция для копирования данных. Она имеет
> формат mov \<приёмник\>, \<источник\>. Например, mov eax, 4 копирует
> число 4 в регистр eax.
>
> 2\. **int** **80h** **(interrupt):** Инструкция, которая вызывает ядро
> Linux для выполнения системной функции (системного вызова).

Чтобы ядро поняло, какую функцию мы хотим, мы перед int 80h должны
поместить номер функции в регистр eax. Параметры для этой функции
кладутся в регистры ebx, ecx, edx.

> 4

**Описание** **результатов** **выполнения** **лабораторной** **работы**

**3.1.** **Задание** **1.** **Работа** **в** **Midnight** **Commander**
**и** **создание** **первой** **программы**

Необходимо было запустить Midnight Commander, создать в нем рабочий
каталог lab05, создать файл lab5-1.asm, отредактировать его, вписав
программу из Листинга 5.1, а затем скомпилировать и запустить ее.

<img src="./jqexrfqq.png"
style="width:7.2868in;height:4.58403in" />Я открыл терминал и ввел
команду mc, чтобы запустить Midnight Commander.

> *Рисунок* *2.* *Главное* *окно* *Midnight* *Commander* *с* *двумя*
> *панелями.*

<img src="./0xkyhmmo.png"
style="width:6.52444in;height:0.98055in" />Используя навигацию, я
перешел в каталог ~/work/arch-pc, который создал в прошлой лабораторной
и нажал клавишу F7 для создания нового каталога и ввел имя lab05.

> *Рисунок* *3.* *Диалоговое* *окно* *создания* *каталога* *(F7)* *в*
> *Midnight* *Commander.*
>
> 5

<img src="./2aa2th0w.png"
style="width:7.15278in;height:1.31944in" />

Зашел в созданный каталог **lab05** и в командной строке под панелями
ввел **touch** **lab5-1.as**m и нажал **Enter**. Файл появился в панели.

> *Рисунок* *4.* *Файл* ***touch*** ***lab5-1.as**m*

<img src="./junfacj0.png"
style="width:4.64028in;height:4.90694in" />Выделив файл lab5-1.asm, я
нажал F4, чтобы открыть его во встроенном редакторе (у меня это был
mcedit).

> *Рисунок* *4.* *Окно* *редактора* *mcedit* *с* *введенным* *кодом*
> *программы* *lab5-1.asm.*
>
> 6

<img src="./gr12r2nd.png"
style="width:4.96847in;height:5.04236in" />Я сохранил файл (клавиша F2)
и вышел из редактора (F10), нажав F3 на файле lab5-1.asm, я убедился,
что его содержимое сохранилось.

> *Рисунок* *5.* *Проверка* *наличие* *кода* *в* *программы*
> *lab5-1.asm.*

<img src="./tcd2qzxe.png"
style="width:7.2868in;height:1.02569in" />Я скрыл панели mc с помощью
Ctrl + O, чтобы получить доступ к командной строке выполнил трансляцию,
компоновку и запуск программы.

> *Рисунок* *6.* *Терминал* *с* *командами* *компиляции* *и*
> *результатом* *запуска* *lab5-1.asm,* *где* *введено* *ФИО.* *.*

Программа вывела сообщение "Введите строку:". Я ввел свои ФИО и нажал
Enter. Программа корректно завершила работу.

На этом этапе я научился базовым операциям в mc: навигации, созданию
каталогов (F7), созданию файлов (touch), редактированию (F4) и просмотру
(F3). Я также собрал и запустил свою первую программу на NASM, используя
системные вызовы write (для вывода), read (для ввода) и exit (для
завершения).

> 7

**3.2.** **Задание** **2.** **Подключение** **внешнего** **файла**
**in_out.asm**

Необходимо было скачать файл in_out.asm, скопировать его в рабочий
каталог, создать копию lab5-1.asm с именем lab5-2.asm и модифицировать
ее для использования подпрограмм из in_out.asm.

<img src="./lwbkp1z2.png"
style="width:6.56389in;height:3.58319in" />В одной панели mc я открыл
свой рабочий каталог ~/work/arch-pc/lab05, a в другой панели mc
(переключившись по Tab) я открыл каталог ~/Загрузки. Я выделил файл
in_out.asm и нажал F5 (Копирование), подтвердив копирование в lab05.

> *Рисунок* *7.* *Окно* *Midnight* *Commander* *с* *диалогом*
> *копирования* *(F5)* *файла* *in_out.asm.*

<img src="./jzvsqtqu.png"
style="width:5.75958in;height:2.45139in" />Далее я выделил файл
lab5-1.asm в папке lab05, нажал F6 (Переименовать/Переместить) и ввел
новое имя lab5-2.asm, чтобы создать копию.

> *Рисунок* *8.* *Окно* *Midnight* *Commander* *с* *диалогом*
> *копирования* *(F5)* *файла* *in_out.asm.*
>
> 8

<img src="./nqbddthq.png" style="width:4.51in;height:6.54861in" />Я
открыл lab5-2.asm на редактирование (F4) и изменил код в соответствии с
Листингом 5.2, используя директиву %include и вызовы call.

> *Рисунок* *9.* *Редактор* *mcedit* *с* *кодом* *программы*
> *lab5-2.asm.*
>
> <img src="./n53nahyb.png"
> style="width:7.2868in;height:1.05278in" />Я сохранил файл и вышел из
> редактора.Снова скрыв панели (Ctrl + O), я скомпилировал и запустил
> lab5-2.asm
>
> *Рисунок* *10.* *Терминал* *с* *компиляцией* *и* *запуском*
> *lab5-2.asm.*
>
> Программа отработала так же, как и lab5-1.asm.
>
> 9

<img src="./vjxlehk2.png"
style="width:7.2868in;height:0.74722in" />Я снова открыл lab5-2.asm и
заменил call sprintLF на call sprint. Сохранил, скомпилировал и
запустил.

> *Рисунок* *11.* *Результат* *работы* *lab5-2.asm* *с* *'sprint'*
> *вместо* *'sprintLF'.* *Приглашение* *консоли* *находится* *на* *той*
> *же* *строке,* *что* *и* *ввод.*

Я научился использовать mc для операций с файлами между панелями (F5,
F6). Использование in_out.asm сильно упрощает код: вместо 4-5 строк для
каждого системного вызова теперь достаточно одной строки call.

**Описание** **результатов** **выполнения** **заданий** **для**
**самостоятельной** **работы**

**4.1.** **Задание** **1.** **Вывод** **введенной** **строки** **(без**
**in_out.asm)**

Мне нужно создать копию lab5-1.asm. Модифицировать программу так, чтобы
она сначала выводила приглашение, затем считывала строку с клавиатуры, а
после этого выводила эту же введенную строку обратно на экран.

<img src="./lbehsxsj.png"
style="width:3.93681in;height:4.10417in" />Я создал копию lab5-1.asm и
назвал ее lab5-task-1.asm и открыл ее в редакторе (F4). После блока
"системный вызов read" я добавил еще один "системный вызов write". Этот
новый вызов использует в качестве адреса (ecx) буфер buf1, куда read
сохранил введенную строку, и ту же длину 80 в edx.

> *Рисунок* *12.* *Редактор* *mcedit* *с* *кодом* *программы*
> *lab5-task-1.asm.*
>
> 10

<img src="./x4bbfh4q.png"
style="width:4.13486in;height:4.31181in" />

<img src="./5pkrxdiz.png"
style="width:7.2868in;height:1.05764in" />Я скомпилировал и запустил
программу. Она попросила ввести строку. Я ввел свою фамилию. Сразу после
нажатия Enter, моя фамилия вывелась на следующей строке.

> *Рисунок* *13.* *Терминал* *с* *запуском* *lab5-task-1.asm,* *где*
> *введена* *фамилия* *и* *она* *же* *выведена* *на* *экран.*

Для вывода введенной строки я просто добавил еще один вызов sys_write
(mov eax, 4), указав ему в ecx адрес буфера buf1, который до этого
заполнил sys_read.

**4.2.** **Задание** **2.** **Вывод** **введенной** **строки** **(с**
**in_out.asm)**

Теперь реализуем тот же алгоритм (приглашение -\> ввод -\> вывод
введенной строки), но с использованием подпрограмм из in_out.asm.

Я создал копию lab5-2.asm и назвал ее lab5-task-2.asm и открыл ее в
редакторе (F4). осле call sread я добавил еще один вызов подпрограммы
sprintLF. Перед этим вызовом я поместил в регистр eax адрес буфера buf1,
так как sprintLF (как и sprint) ожидает в eax адрес того, что нужно
напечатать.

> *Рисунок* *14.* *Редактор* *mcedit* *с* *кодом* *программы*
> *lab5-task-2.asm* *.*
>
> 11

<img src="./nfi5nj0v.png"
style="width:7.2868in;height:1.39931in" />Я скомпилировал и запустил
программу. Она отработала аналогично lab5-task-1.asm.

> *Рисунок* *15* *Терминал* *с* *запуском* *lab5-task-2.asm,* *где*
> *введена* *фамилия* *и* *она* *же* *выведена* *на* *экран.*

Эта задача решается еще проще с in_out.asm. Я просто добавил mov eax,
buf1 и call sprintLF после call sread. Код получается намного чище и
понятнее.

> 12

**Вывод**

Я получил практические навыки работы с файловым менеджером Midnight
Commander: я научился создавать каталоги (F7), файлы (с помощью touch),
редактировать их (F4), просматривать (F3), копировать (F5) и
переименовывать (F6). Также я освоил базовую структуру программы на
ассемблере NASM (секции .data, .bss, .text) и научился использовать
ключевые инструкции:

> • **mov**: для перемещения данных (адресов, констант) в регистры (eax,
> ebx, ecx, edx) для подготовки системных вызовов.
>
> • **int** **80h**: для вызова ядра Linux и выполнения системных
> функций, таких как sys_write, sys_read и sys_exit

Я также научился подключать внешние файлы (%include) и использовать
подпрограммы (call), что значительно упрощает написание кода.

> 13

**Список** **литературы**

> 1\. GDB: The GNU Project Debugger. — URL:
> https://www.gnu.org/software/gdb/.
>
> 2\. GNU Bash Manual. — 2016. — URL:
> https://www.gnu.org/software/bash/manual/.
>
> 3\. Midnight Commander Development Center. — 2021. — URL:
> https://midnight-commander.org/. 4. NASM Assembly Language Tutorials.
> — 2021. — URL: https://asmtutor.com/.
>
> 5\. Newham C. Learning the bash Shell: Unix Shell Programming. —
> O’Reilly Media, 2005. — 354 с. — (In a Nutshell). — ISBN 0596009658. —
> URL:
> http://www.amazon.com/Learning-bash-Shell-Programming-Nutshell/dp/0596009658.
>
> 6\. Robbins A. Bash Pocket Reference. — O’Reilly Media, 2016. — 156 с.
> — ISBN 978-1491941591. 7. The NASM documentation. — 2021. — URL:
> https://www.nasm.us/docs.php.
>
> 8\. Zarrelli G. Mastering Bash. — Packt Publishing, 2017. — 502 с. —
> ISBN 9781784396879. 9. Колдаев В. Д., Лупин С. А. Архитектура ЭВМ. —
> М. : Форум, 2018.
>
> 10\. Куляс О. Л., Никитин К. А. Курс программирования на ASSEMBLER. —
> М. : Солон-Пресс, 2017.
>
> 11\. Новожилов О. П. Архитектура ЭВМ и систем. — М. : Юрайт, 2016.
>
> 12\. Расширенный ассемблер: NASM. — 2021. — URL:
> https://www.opennet.ru/docs/RUS/nasm/. 13. Робачевский А., Немнюгин
> С., Стесик О. Операционная система UNIX. — 2-е изд. — БХВ-
>
> Петербург, 2010. — 656 с. — ISBN 978-5-94157-538-1.
>
> 14\. Столяров А. Программирование на языке ассемблера NASM для ОС
> Unix. — 2-е изд. — М. : МАКС Пресс, 2011. — URL:
> http://www.stolyarov.info/books/asm_unix.
>
> 15\. Таненбаум Э. Архитектура компьютера. — 6-е изд. — СПб. : Питер,
> 2013. — 874 с. — (Классика Computer Science).
>
> 16\. Таненбаум Э., Бос Х. Современные операционные системы. — 5-е изд.
> — СПб. : Питер, 2018. — 1120 с. — (Классика Computer Science).
>
> 14
