**РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ** 

**Факультет физико-математических и естественных наук Кафедра прикладной информатики и теории вероятностей** 

**ОТЧЕТ**  

**ПО ЛАБОРАТОРНОЙ РАБОТЕ № 9** 

*дисциплина:  Архитектура компьютера ![](Aspose.Words.75ac6806-ff89-4637-bef5-0a46380c7143.001.png)*

Студент: Грицко Сергей         Группа: НКАбд-02-25         

**МОСКВА** 2025 г. 

Оглавление 

[Цель работы....................................................................................................................................................................... 3 ](#_page2_x54.00_y56.92)[Теоретическое введение ................................................................................................................................................... 4 ](#_page3_x54.00_y56.92)[Выполнение лабораторной работы ................................................................................................................................. 6 ](#_page5_x54.00_y56.92)

1. [Реализация подпрограмм в NASM ....................................................................................................................... 6 ](#_page5_x54.00_y131.92)
1. [Отладка программ с помощью GDB .................................................................................................................... 7 ](#_page6_x54.00_y56.92)
1. [Аргументы командной строки в GDB .................................................................................................................. 9 ](#_page8_x54.00_y56.92)

[Выполнение заданий для самостоятельной работы....................................................................................................... 9 ](#_page8_x54.00_y425.92)

[Задание 1. Преобразование программы (Вариант 14) ............................................................................................... 9 ](#_page8_x54.00_y479.92)

[Задание 2. Альтернативная реализация (Вариант 14)................................................................................................ 9 ](#_page8_x54.00_y726.92)[Выводы ............................................................................................................................................................................10 ](#_page9_x54.00_y258.92)[Список литературы .........................................................................................................................................................11 ](#_page10_x54.00_y56.92)

<a name="_page2_x54.00_y56.92"></a>**Цель работы** 

Приобретение навыков написания программ с использованием подпрограмм. Знакомство с методами отладки при помощи GDB и его основными возможностями. 

<a name="_page3_x54.00_y56.92"></a>**Теоретическое введение**

Отладка — это процесс поиска и исправления ошибок в программе. Этот процесс можно разделить на четыре ключевых этапа, которые выполняются последовательно: 

1. **Обнаружение ошибки (Detection):** Фиксация того факта, что программа ведет себя не так, как ожидалось (например, падает или выдает неверный результат). 
1. **Поиск её местонахождения (Localization):** Выделение конкретного фрагмента кода, который вызывает проблему. Для этого часто применяется метод «разделяй и властвуй», когда большие участки кода проверяются изолированно. 
1. **Определение причины (Diagnosis):** Выяснение точной логической или структурной причины, по которой этот фрагмент кода работает некорректно. 
1. **Исправление (Correction):** Внесение изменений в код для устранения выявленной причины. 

Существуют различные типы ошибок, требующие разных подходов к исправлению: 

1. **Синтаксические:** Это ошибки в правилах языка ассемблера (например, опечатка в имени инструкции или неправильный порядок операндов). Они обнаруживаются на этапе трансляции (компиляции) и не позволяют создать исполняемый файл. Компилятор (NASM) обычно точно указывает строку, где была допущена ошибка. 
1. **Семантические (логические):** Самый сложный тип для отладки. Программа запускается и завершается без сбоев, но результат не соответствует заданию. Например, вместо сложения используется вычитание, или не учтено соглашение о регистрах. Такие ошибки требуют пошагового анализа с помощью отладчика. 
1. **Ошибки выполнения (Runtime Errors):** Не обнаруживаются компилятором, но приводят к аварийному завершению программы (краху) во время ее работы. Типичными примерами являются переполнение регистров, попытка деления на ноль, или обращение к неверному адресу памяти. 

Основными методами отладки являются вывод диагностических сообщений (промежуточных значений переменных или состояния регистров) и использование специальных программ- отладчиков, таких как GDB (GNU Debugger). 

![](Aspose.Words.75ac6806-ff89-4637-bef5-0a46380c7143.002.jpeg)

*Рисунок 1. GNU Debugger* 

Отладчики позволяют выполнять программу по шагам (построчно), просматривать значения регистров и переменных, а также устанавливать точки останова (breakpoints) — места, где выполнение программы принудительно прерывается для ручного анализа текущего состояния. 

**Понятие подпрограммы** **Подпрограмма (или процедура)** — это именованный, самодостаточный блок кода, предназначенный для выполнения определенной задачи. Использование подпрограмм позволяет избежать дублирования кода, делает программу более модульной и удобной для чтения и отладки. Для работы с подпрограммами в ассемблере используются две ключевые инструкции, которые тесно связаны со стеком: 

1. call — вызов подпрограммы. При выполнении этой инструкции процессор **сохраняет адрес следующей инструкции** (адрес возврата) в стеке и передает управление по адресу метки подпрограммы. 
1. ret — возврат из подпрограммы. Эта инструкция **извлекает сохраненный адрес** из вершины стека и передает управление по этому адресу, тем самым возвращаясь в основную программу (или вызывающую подпрограмму) ровно туда, откуда был произведен вызов. 

Это обеспечивает автоматический и корректный возврат управления, что критически важно для реализации как простых, так и вложенных вызовов. 

<a name="_page5_x54.00_y56.92"></a>**Выполнение лабораторной работы**

1. ***Реализация<a name="_page5_x54.00_y131.92"></a> подпрограмм в NASM*** 

Мною была создана программа lab09-1.asm для вычисления сложного выражения $f(g(x))$, 

где $f(x) = 2x+7$, а $g(x) = 3x-1$. 

Для реализации этой задачи я применил принцип модульности, используя вложенные подпрограммы. Это позволяет разделить логику вычислений на независимые блоки. Основная программа вызывает подпрограмму \_calcul, которая отвечает за внешнюю функцию $f(x)$. В свою очередь, \_calcul вызывает вложенную подпрограмму \_subcalcul для предварительного вычисления значения внутренней функции $g(x)$. Передача результатов вычислений между подпрограммами осуществляется через регистр EAX, что является стандартным соглашением для возврата значений. 

Текст программы lab9-1.asm: (Смотри файл lab9-1.asm, приложенный к отчету) 

![](Aspose.Words.75ac6806-ff89-4637-bef5-0a46380c7143.003.png)

*Рисунок 2. **Запуск и проверка программы lab09-1*** 

Я скомпилировал файл и проверил его корректность на тестовом значении $x = 2$. Проверка правильности выполнения проводилась пошагово: 

1. Сначала вычисляется внутренняя функция: $g(2) = 3 \cdot 2 - 1 = 5$. 
1. Затем результат передается во внешнюю функцию: $f(5) = 2 \cdot 5 + 7 = 17$. Программа выдала ожидаемый результат 17, что подтверждает корректность работы вложенных вызовов и инструкции ret. 
2. ***Отладка<a name="_page6_x54.00_y56.92"></a> программ с помощью GDB*** 

Я создал файл lab09-2.asm, выводящий сообщение "Hello World", и скомпилировал его с ключом -g. Использование этого ключа критически важно, так как он добавляет в исполняемый файл отладочную информацию, позволяющую отладчику сопоставлять машинный код с исходным текстом программы. Затем я загрузил исполняемый файл в отладчик gdb. 

![](Aspose.Words.75ac6806-ff89-4637-bef5-0a46380c7143.004.jpeg)

*Рисунок 3. **Запуск GDB*** 

В ходе работы с отладчиком я выполнил ряд действий для анализа состояния процессора: 

1. Запустил программу командой run. 
1. Установил точку останова на начальную метку \_start с помощью команды break \_start, чтобы прервать выполнение перед первой инструкцией. 
1. Включил режим дизассемблирования (disassemble) и переключился на синтаксис Intel командой set disassembly-flavor intel. Это сделало код более читаемым, так как порядок операндов стал привычным (приемник, источник), как в исходном коде NASM, в отличие от стандартного для GDB синтаксиса AT&T. 
1. Активировал псевдографический интерфейс командой layout asm и layout regs. Это разделило окно терминала на области, отображающие текущий ассемблерный код, состояние регистров и командную строку. 

Используя команду si (step instruction) для пошагового выполнения, я наблюдал, как меняются значения в регистрах eax, ebx, ecx и edx после каждой инструкции mov и int. Я также следил за регистром eip (Instruction Pointer), который указывал на адрес следующей выполняемой команды. 

![](Aspose.Words.75ac6806-ff89-4637-bef5-0a46380c7143.005.jpeg)

*Рисунок 4. **Работа в GDB (просмотр регистров)*** 

3. ***Аргументы<a name="_page8_x54.00_y56.92"></a> командной строки в GDB*** 

Для изучения передачи параметров я скопировал программу из предыдущей лабораторной работы в файл lab09-3.asm и запустил её под отладчиком с указанием аргументов командной строки. Особое внимание было уделено анализу стека. 

Исследовав вершину стека с помощью команды x/x $esp (просмотр памяти по адресу регистра Stack Pointer), я убедился в следующем: 

1. Вершина стека (адрес в $esp) хранит количество аргументов (argc). 
1. Следующая ячейка памяти по адресу $esp + 4 содержит адрес имени программы. 
1. Далее, по адресам $esp + 8, $esp + 12 и так далее, хранятся указатели на строки самих аргументов. 

Шаг смещения равен 4 байтам, поскольку мы работаем в 32-битной архитектуре, где каждый адрес памяти занимает ровно 4 байта (32 бита). Это наблюдение подтверждает теоретические знания о том, как операционная система передает данные в программу при запуске. 

<a name="_page8_x54.00_y425.92"></a>**Выполнение заданий для самостоятельной работы** 

<a name="_page8_x54.00_y479.92"></a>***Задание 1. Преобразование программы (Вариант 14)*** 

Согласно варианту 14, мне необходимо вычислить функцию $f(x) = 2x + 10$ (на основе 

заданий из ЛР №8). Я выделил вычисление функции в отдельную подпрограмму \_function\_variant. 

**Листинг программы (основные части):** 

![](Aspose.Words.75ac6806-ff89-4637-bef5-0a46380c7143.006.png)

*Рисунок 5. **Проверка работы программы*** 

<a name="_page8_x54.00_y726.92"></a>***Задание 2. Альтернативная реализация (Вариант 14)*** 

Второе задание заключалось в альтернативной реализации функции Варианта 14 ($f(x) = 2x + 

10$). Эта реализация была выполнена без использования подпрограммы (в отличие от Задания 1) для демонстрации прямого вычисления. 

**Листинг программы (основные части):** 

![](Aspose.Words.75ac6806-ff89-4637-bef5-0a46380c7143.007.png)

*Рисунок 6. **Запуск альтернативной реализации*** 

<a name="_page9_x54.00_y258.92"></a>**Выводы** 

В ходе лабораторной работы я: 

1. Научился оформлять повторяющиеся участки кода в виде подпрограмм, используя инструкции call и ret. 
1. Понял принцип работы стека при вызове процедур (сохранение адреса возврата). 
1. Освоил работу с отладчиком GDB: запуск, пошаговое выполнение (si), установка точек останова (break), просмотр регистров (info registers) и памяти (x). 
1. Научился использовать отладчик для поиска логических ошибок в ассемблерном коде. 

<a name="_page10_x54.00_y56.92"></a>**Список литературы**  

1. GDB: The GNU Project Debugger. — URL: [https://www.gnu.org/software/gdb/. ](https://www.gnu.org/software/gdb/) 
1. NASM Assembly Language Tutorials. — 2021. — URL: [https://asmtutor.com/. ](https://asmtutor.com/) 
1. Колдаев В. Д., Лупин С. А. Архитектура ЭВМ. — М. : Форум, 2018.  
1. Куляс О. Л., Никитин К. А. Курс программирования на ASSEMBLER. — М. : Солон- Пресс, 2017.  
1. Столяров А. Программирование на языке ассемблера NASM для ОС Unix. — 2-е изд. М. : МАКС Пресс, 2011. 6. Таненбаум Э. Архитектура компьютера. — 6-е изд. — СПб. : Питер, 2013. — 874 с. 12 
11 
